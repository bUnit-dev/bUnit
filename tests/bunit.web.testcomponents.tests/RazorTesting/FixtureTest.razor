@inherits TestComponentBase

<Fixture TestAsync="CanGetComponentInsideCascadingValue" Description="GetComponentUnderTest can find component inside CascadingValue">
	<ComponentUnderTest>
		<CascadingValue Value="true">
			<ClickCounter />
		</CascadingValue>
	</ComponentUnderTest>

	@code
	{
		async Task CanGetComponentInsideCascadingValue(Fixture fixture)
		{
			var cut = await fixture.GetComponentUnderTest<ClickCounter>();
			cut.ShouldNotBeNull();
		}
	}
</Fixture>

<Fixture TestAsync="Test004" Description="Calling GetComponentUnderTest multiple times returns same instance">
	<ComponentUnderTest>
		<Wrapper>CUT</Wrapper>
	</ComponentUnderTest>
	@code
	{
		async Task Test004(Fixture f)
		{
			var cut1 = await f.GetComponentUnderTest<Wrapper>();
			var cut2 = await f.GetComponentUnderTest<Wrapper>();

			cut1.ShouldBe(cut2);
		}
	}
</Fixture>

<Fixture TestAsync="Test005" Description="Calling GetFragment with same args multiple times returns same instance">
	<Fragment Id="first">first</Fragment>
	<Fragment Id="second">second</Fragment>
	@code
	{
		async Task Test005(Fixture f)
		{
			var firstFragmentNoId1 = await f.GetFragment();
			var firstFragmentNoId2 = await f.GetFragment();
			var firstFragmentId1 = await f.GetFragment("first");
			var firstFragmentId2 = await f.GetFragment("first");

			firstFragmentNoId1.ShouldBe(firstFragmentNoId2);
			firstFragmentId1.ShouldBe(firstFragmentId2);
		}
	}
</Fixture>

<Fixture TestAsync="Test006" Description="Getting first fragment with and without id should return the same instance">
	<Fragment Id="first">first</Fragment>
	<Fragment Id="second">second</Fragment>
	@code
	{
		async Task Test006(Fixture f)
		{
			var firstFragmentNoId1 = await f.GetFragment();
			var firstFragmentId1 = await f.GetFragment("first");

			firstFragmentNoId1.ShouldBe(firstFragmentId1);
		}
	}
</Fixture>

<Fixture TestAsync="Test007" Description="Using the generic GetFragment returns an IRenderedComponent with the component of the generic type">
	<Fragment><Wrapper /></Fragment>
	@code
	{
		async Task Test007(Fixture f)
		{
			var fragment = await f.GetFragment<Wrapper>();

			fragment.ShouldBeAssignableTo<IRenderedComponent<Wrapper>>()
				.Instance.ShouldNotBeNull();
		}
	}
</Fixture>

<Fixture TestAsync="Test008" Description="Using the generic GetComponentUnderTest returns an IRenderedComponent with the component of the generic type">
	<ComponentUnderTest><Wrapper /></ComponentUnderTest>
	@code
	{
		async Task Test008(Fixture f)
		{
			var cut = await f.GetComponentUnderTest<Wrapper>();

			cut.ShouldBeAssignableTo<IRenderedComponent<Wrapper>>()
				.Instance.ShouldNotBeNull();
		}
	}
</Fixture>

<Fixture TestAsync="Test009" Description="Using the non-generic GetFragment returns an IRenderedFragment">
	<Fragment><Wrapper /></Fragment>
	@code
	{
		async Task Test009(Fixture f)
		{
			var fragment = await f.GetFragment();

			fragment.ShouldBeAssignableTo<IRenderedFragment>();
		}
	}
</Fixture>

<Fixture TestAsync="Test010" Description="Using the non-generic GetComponentUnderTest returns an IRenderedFragment">
	<ComponentUnderTest><Wrapper /></ComponentUnderTest>
	@code
	{
		async Task Test010(Fixture f)
		{
			var cut = await f.GetComponentUnderTest();

			cut.ShouldBeAssignableTo<IRenderedFragment>();
		}
	}

</Fixture>

<Fixture TestAsync="Test011" Description="Calling generic get-methods after non-generic throws">
	<ComponentUnderTest>
		<Wrapper>CUT</Wrapper>
	</ComponentUnderTest>
	<Fragment>
		<Wrapper>second</Wrapper>
	</Fragment>
	@code
	{
		async Task Test011(Fixture f)
		{
			await f.GetComponentUnderTest();

			// It should not be possible to call the generic GetComponentUnderTest after the non-generic has been called
			await Assert.ThrowsAsync<InvalidOperationException>(() => f.GetComponentUnderTest<Wrapper>());

			await f.GetFragment();

			// It should not be possible to call the generic GetFragment after the non-generic has been called
			await Assert.ThrowsAsync<InvalidOperationException>(() => f.GetFragment<Wrapper>());
		}
	}
</Fixture>

<Fixture TestAsync="Test012" Description="Calling get-methods with wrong generic type throws">
	<ComponentUnderTest>
		<Wrapper></Wrapper>
	</ComponentUnderTest>
	<Fragment>
		<Wrapper></Wrapper>
	</Fragment>
	@code
	{
		async Task Test012(Fixture f)
		{
			await Assert.ThrowsAsync<ComponentNotFoundException>(() => f.GetComponentUnderTest<Simple1>());
			await Assert.ThrowsAsync<ComponentNotFoundException>(() => f.GetFragment<Simple1>());
		}
	}
</Fixture>

<Fixture Setup="Setup020" TestAsync="Test020" Description="Renders CUT inside components added to RenderTree and returns correct CUT from GetComponentUnderTest">
	<ComponentUnderTest>
		<PrintCascadingValue />
	</ComponentUnderTest>
	@code
	{
		void Setup020(Fixture f)
		{
			f.RenderTree.Add<CascadingValue<string>>(ps => ps.Add(p => p.Value, "FOO"));
			f.RenderTree.Add<WrapperDiv>();
		}

		async Task Test020(Fixture f)
		{
			var component = await f.GetComponentUnderTest();
			component.MarkupMatches("<p>FOO</p>");
		}
	}
</Fixture>

<Fixture Setup="Setup021" TestAsync="Test021" Description="Renders CUT inside components added to RenderTree and returns correct CUT from generic GetComponentUnderTest<T>">
	<ComponentUnderTest>
		<PrintCascadingValue />
	</ComponentUnderTest>
	@code
	{
		void Setup021(Fixture f)
		{
			f.RenderTree.Add<CascadingValue<string>>(ps => ps.Add(p => p.Value, "FOO"));
			f.RenderTree.Add<WrapperDiv>();
		}

		async Task Test021(Fixture f)
		{
			var component = await f.GetComponentUnderTest<PrintCascadingValue>();
			component.MarkupMatches("<p>FOO</p>");
		}
	}
</Fixture>

<Fixture TestAsync="Test030" Description="Can raise events from markup rendered with Fixture">
	<ComponentUnderTest>
		<ClickCounter></ClickCounter>
	</ComponentUnderTest>
	@code
	{
		async Task Test030(Fixture f)
		{
			var component = await f.GetComponentUnderTest();
			component
				.Find("button")
				.Click();
		}
	}
</Fixture>
