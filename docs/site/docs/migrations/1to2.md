---
uid: migrating-from-1-to-2
title: Migrating from 1.x to 2.x
---

# Migrating from bUnit 1.x to 2.x
This document describes the changes made in bUnit 2.x that may affect  existing tests written for bUnit 1.x. The old documentation for bUnit 1.x is available at: https://v1.bunit.dev.

## One package to rule them all
`bunit.core` and `bunit.web` have be merged into a single package called `bunit`. The seperation was used to allow for extensibitlity, which isn't used anymore. Therefore `bunit.core` and `bunit.web` will stay on version 1.x, while `bunit` will be the only package going forward. To migrate, simply remove the `bunit.core` and `bunit.web` packages and add the `bunit` package. We don't expect many users to have used the `bunit.core` or `bunit.web`  package directly, but may hit 3rd party packages that depend on them. 

## `TestContext` renamed to `BunitContext`

The `TestContext` class has been renamed to `BunitContext`. To migrate tests, rename all instances of `TestContext` to `BunitContext`:

```diff
- public class MyTestClass : TestContext
+ public class MyTestClass : BunitContext
```

## `BunitContext` offers `Dispose` and `DisposeAsync` methods
In version 1, the `TestContext` class only implemented `IDisposable`, but in version 2, it also implements `IAsyncDisposable`. Therefore, if there are asynchronous disposable inside the container for example, the asynchronous version should be used.

## The `Fake` prefix was renamed to `Bunit` (e.g. `FakeNavigationManager` to `BunitNavigationManager`)
The `Fake` prefix used for various fake implementations has been renamed to `Bunit`. This includes the following types:
 * `FakeNavigationManager` to `BunitNavigationManager`
 * `FakeJSRuntime` to `BunitJSRuntime`
 * `FakeAuthenticationStateProvider` to `BunitAuthenticationStateProvider`
 * `FakeAuthrozitationContext` to `BunitAuthorizationContext`
 * `FakeuthorizationPolicyProvider` to `BunitAuthorizationPolicyProvider`
  
## Unified the `Render` methods
In v1 there were multiple `RenderXXX`methods (like `RenderComponent`, `Render` and `SetParametersAndRender`) that were used to render components and markup. In v2, these methods have been unified into a single `Render` method that can handle both components and markup) via the simple `Render` method:

```diff
- var cut = RenderComponent<MyComponent>();
+ var cut = Render<MyComponent>();
```

## Removed some abstraction
Many types were removed in favor of one public type:
 * `IRenderedComponent<TComponent>` - where `TComponent` is the type of the component rendered (or the a `ContainerFragment` if markup was rendered).

The removed types were:
 * `IRenderedFragment`
 * `IRenderedComponent`
 * `IRenderedMarkup`
 * `IRenderedComponentBase`

If any of the types were used (for example in extensions methods), they should be replaced with `IRenderedComponent`.

## Removed of `IsNullOrEmpty` extension method on `IEnumerable<T>` and `CreateLogger` on `IServiceProvider`
The `IsNullOrEmpty` extension method on `IEnumerable<T>` has been removed, as well as the `CreateLogger` extension method on `IServiceProvider`. These extension methods are pretty common and conflict with other libraries. These methods can be recreated like this:

```csharp
public static class Extensions
{
    public static bool IsNullOrEmpty<T>(this IEnumerable<T> enumerable)
        => enumerable == null || !enumerable.Any();
    
    public static ILogger<T> CreateLogger<T>(this IServiceProvider serviceProvider)
    {
        var loggerFactory = serviceProvider.GetRequiredService<ILoggerFactory>() ?? NullLoggerFactory.Instance;
        return loggerFactory.CreateLogger<T>();
    }
}
```

## Event dispatcher does not offer overload with all parameters

In version 1.x, bUnit offered for example the following methods to invoke `onclick` on a component:

```csharp
cut.Find("button").Click();
cut.Find("button").ClickAsync(new MouseEventArgs());
cut.Find("button").Click(detail: 2, ctrlKey: true);
```

The last one was a method with all parameters of `MouseEventArgs` as optional parameters. This method has been removed in favor of using the `MouseEventArgs` directly.

Also `ClickAsync` - to align with its synchronous counterpart - doesn't take `MouseEventArgs` as mandatory parameter anymore. If not set, a default instance will be created.